<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring boot入门]]></title>
    <url>%2F2019%2F07%2F29%2FSpringBoot%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot入门一、环境准备：IntelliJ IDEA + maven + springboot2.x 二、创建项目和启动项目：1、利用spring Initializr创建项目 2、输出项目名称等，点击next 3、选择springboot版本，web模块 4、选择项目位置，点击finish 5、等待一段时间，带项目创建完成后，将多余的文件及文件夹删除，最终的项目结构如图 6、新建controller包，并新建HelloController类，指定访问路径“/hello”，为浏览器返回字符串“hello world!” 7、启动主Application类的main方法 8、浏览器地址栏输出localhost:8080/hello，结果如图]]></content>
      <categories>
        <category>后端</category>
        <category>JavaWeb</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看得见的算法]]></title>
    <url>%2F2018%2F05%2F18%2F%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[看得见的算法跟着慕课网的老师学习，用Java Swing所做的几个小demo，《看得见的算法》课程地址链接：[点击这里] 第一章、碰撞的小球1、 创建一个JFrame窗体1234567891011121314151617181920212223242526public class CircleFrame extends JFrame &#123; private int canvasWidth; private int canvasHeight; public CircleFrame(String title, int canvasWidth, int canvasHeight) &#123; super(title); this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight; this.setSize(canvasWidth, canvasHeight); this.setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setVisible(true); &#125; public CircleFrame(String title) &#123; this(title, 1024, 768); &#125; public int getCanvasWidth() &#123; return canvasWidth; &#125; public int getCanvasHeight() &#123; return canvasHeight; &#125;&#125; 启动类：将窗体的创建放进java.awt的事件队列中。(我自己也不是很明白，讲解的老师说官方推荐这样做) 123456789public class Main &#123; public static void main(String[] args) &#123; EventQueue.invokeLater(() -&gt; &#123; new CircleFrame("碰撞的小球", 500, 500); //new CircleFrame("碰撞的小球"); &#125;); &#125;&#125; 运行 2、为JFrame添加JPanel画布12345678910111213141516171819202122232425262728public class CircleFrame extends JFrame &#123; // ... public CircleFrame(String title, int canvasWidth, int canvasHeight) &#123; // ... this.canvasHeight = canvasHeight; CircleCanvas canvas = new CircleCanvas(); this.setContentPane(canvas); this.pack(); this.setResizable(false); // ... &#125; // ... private class CircleCanvas extends JPanel &#123; @Override protected void paintComponent(Graphics g) &#123; super.paintComponent(g); g.drawOval(50, 50, 300, 300); &#125; @Override public Dimension getPreferredSize() &#123; return new Dimension(canvasWidth, canvasHeight); &#125; &#125;&#125; 继续运行main方法 3、使用Graphics2D进行绘图1234567891011121314public class CircleFrame extends JFrame &#123; // ... private class CircleCanvas extends JPanel &#123; @Override protected void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; Ellipse2D circle = new Ellipse2D.Double(50, 50, 300,300); g2d.draw(circle); &#125; // ... &#125;&#125; Graphics2D相关接口： 4、整理绘制工具类CircleHelper.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class CircleHelper &#123; private CircleHelper() &#123;&#125; public static final Color Red = new Color(0xF44336); public static final Color Pink = new Color(0xE91E63); public static final Color Purple = new Color(0x9C27B0); public static final Color DeepPurple = new Color(0x673AB7); public static final Color Indigo = new Color(0x3F51B5); public static final Color Blue = new Color(0x2196F3); public static final Color LightBlue = new Color(0x03A9F4); public static final Color Cyan = new Color(0x00BCD4); public static final Color Teal = new Color(0x009688); public static final Color Green = new Color(0x4CAF50); public static final Color LightGreen = new Color(0x8BC34A); public static final Color Lime = new Color(0xCDDC39); public static final Color Yellow = new Color(0xFFEB3B); public static final Color Amber = new Color(0xFFC107); public static final Color Orange = new Color(0xFF9800); public static final Color DeepOrange = new Color(0xFF5722); public static final Color Brown = new Color(0x795548); public static final Color Grey = new Color(0x9E9E9E); public static final Color BlueGrey = new Color(0x607D8B); public static final Color Black = new Color(0x000000); public static final Color White = new Color(0xFFFFFF); /** * 设置线条的宽度及&lt;b&gt;其他参数&lt;/b&gt; */ public static void setStrokeWidth(Graphics2D g2d, int width) &#123; g2d.setStroke(new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND)); &#125; /** * 设置画笔颜色 */ public static void setColor(Graphics2D g2d, Color color) &#123; g2d.setColor(color); &#125; /** * 画一个空心圆 * @param g2d * @param x 圆心横坐标 * @param y 圆心纵坐标 * @param r 半径 */ public static void drawCircle(Graphics2D g2d, int x, int y, int r) &#123; Ellipse2D circle = new Ellipse2D.Double(x-r, y-r, 2*r, 2*r); g2d.draw(circle); &#125; /** * 画一个实心圆 * @param r 半径 */ public static void fillCircle(Graphics2D g2d, int x, int y, int r) &#123; Ellipse2D circle = new Ellipse2D.Double(x-r, y-r, 2*r, 2*r); g2d.fill(circle); &#125; public static void pause(int t) &#123; try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用工具类进行绘制： 123456789101112131415public class CircleFrame extends JFrame &#123; // ... private class CircleCanvas extends JPanel &#123; @Override protected void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; CircleHelper.setStrokeWidth(g2d, 1); CircleHelper.setColor(g2d, Color.RED); CircleHelper.drawCircle(g2d, 200, 200, 150); &#125; // ... &#125;&#125; BasicStroke相关参数： 5、抗锯齿和双缓存抗锯齿抗锯齿原理： java中打开抗锯齿： 123456789101112 @Override protected void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; // 抗锯齿 RenderingHints hints = new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2d.addRenderingHints(hints); // 具体绘制 // ...&#125; 开启抗锯齿前后效果对比： 更多java抗锯齿处理相关api请自行查阅java官方文档 双缓存首先需要了解单缓存的原理和缺点 单缓存单缓存中，一块屏幕只对应一个画布，画布的内容会投影给屏幕。画布在每次绘制内容时，都会先清空画布原有的所有内容，再对内容进行重新绘制。因此在两次绘制间隔会有一段空白，就会造成屏幕的“闪烁”现象。 双缓存技术原理：一块屏幕对应了两个画布，当画布进行绘制，首先并不会清空内容，而是由另一块画布绘制下一次内容的状态。在绘制的过程中，第一块画布一直会投影给屏幕，等到第二块画布绘制完成后，第一块画布取消投影，由第二块画布将绘制好的内容投影给屏幕。然后第一块画布接着绘制下一状态的内容，同时第二块画布会一直投影给屏幕…这样交替绘制交替投影，从而消除单缓存的缺点。 java中开启双缓存其实非常简单，为我们的画布类添加构造方法，再在构造方法中调用父类构造方法将参数设置为true就行。 12345private class CircleCanvas extends JPanel &#123; public CircleCanvas() &#123; super(true); // 双缓存，java8默认是打开的，甚至都不用我们创建这个构造函数 &#125; &#125; 抗锯齿和双缓存技术主要是计算机图形学的范畴，想要深入学习的同学建议网上查阅相关资料，自行了解。 6、动画基础：绘制运动的小球6、1 首先需要建立小球数据创建Circle.java 12345678910111213141516171819202122232425262728293031323334public class Circle &#123; public int x, y; // 小球圆心坐标 private int r; // 半径 public int vx, vy; // 水平与垂直方向的速度分量 public Circle(int x, int y, int r, int vx, int vy) &#123; this.x = x; this.y = y; this.r = r; this.vx = vx; this.vy = vy; &#125; public int getR() &#123; return r; &#125; // 简单的小球运动逻辑（数据的更新） public void move(int minX, int minY, int maxX, int maxY) &#123; x += vx; y += vy; checkWallCollision(minX, minY, maxX, maxY); &#125; // 球与墙的碰撞检测 private void checkWallCollision(int minX, int minY, int maxX, int maxY) &#123; if (x - r &lt; minX) &#123; x = r; vx = -vx;&#125; if (x + r &gt;= maxX) &#123; x = maxX - r; vx = -vx;&#125; if (y - r &lt; minY) &#123; y = r; vy = -vy;&#125; if (y + r &gt;= maxY) &#123; y = maxY - r; vy = -vy;&#125; &#125;&#125; 6、2 将Circle的数据传递给CircleFrame，使窗体能够对小球的数据进行绘制。在CircleFrame.java中设置一个新的成员属性和方法，然后在画布类的paintComponent方法的具体绘制处实现对每一个小球的绘制逻辑 1234567891011121314151617181920212223242526public class CircleFrame extends JFrame &#123; // ... private Circle[] circles; // 我们要绘制多个小球，所以是Circle[] public void render(Circle[] circles) &#123; this.circles = circles; this.repaint(); // 调用repaint方法进行画布的刷新 &#125; private class CircleCanvas extends JPanel &#123; // ... @Override protected void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; // 抗锯齿 // ... // 具体绘制 CircleHelper.setStrokeWidth(g2d, 1); CircleHelper.setColor(g2d, Color.RED); for (Circle circle : circles) &#123; // 绘制每一个圆 CircleHelper.drawCircle(g2d, circle.x, circle.y, circle.getR()); &#125; &#125; &#125;&#125; 6、3 在启动类中进行Circle数据和窗体大小的初始化，在事件队列中进行对窗体的渲染和数据更新。12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; // 数据的初始化 int sceneWidth = 1000; int sceneHeight = 1000; int N = 10; Circle[] circles = new Circle[N]; int R = 50; for (int i = 0; i &lt; N; i++) &#123; int x = (int) ((Math.random() * (sceneWidth - 2 * R)) + R); int y = (int) ((Math.random() * (sceneHeight - 2 * R)) + R); int vx = (int) (Math.random() * 11) - 5; int vy = (int) (Math.random() * 11) - 5; circles[i] = new Circle(x, y, R, vx, vy); &#125; // 事件派生队列 EventQueue.invokeLater(() -&gt; &#123; CircleFrame frame = new CircleFrame("碰撞的小球", sceneWidth, sceneHeight); while (true) &#123; // 窗体渲染 frame.render(circles); CircleHelper.pause(20); // 更新数据 for (Circle circle : circles) &#123; circle.move(0, 0, sceneWidth, sceneHeight); &#125; &#125; &#125;);&#125; 6、4 启动程序后发现的错误及解决方法启动程序 发现程序并未能向我们预计的那样正确运行，首先是窗体并未绘制出小球，其次我们想点击窗体的关闭按钮来关闭窗体也做不到，程序被卡死。 产生错误的原因： 我们在一开始将窗体的创建放进了一个事件队列中，而在java程序中，这个事件队列处理的不光是窗体的创建这一个事件，还有许多其他的事件。而我们现在在这个事件队列中放入一个了while (true) {…}的死循环，这个死循环的事件相对于其他事件来说是一个无穷无尽的事件，也就会造成事件中的阻塞现象。也是此次程序卡死的原因。 解决方案： 将这个死循环抽取出来放进一个线程中。 1234567891011121314EventQueue.invokeLater(() -&gt; &#123; CircleFrame frame = new CircleFrame("碰撞的小球", sceneWidth, sceneHeight); new Thread(() -&gt; &#123; while (true) &#123; // 绘制数据 frame.render(circles); CircleHelper.pause(20); // 更新数据 for (Circle circle : circles) &#123; circle.move(0, 0, sceneWidth, sceneHeight, circles); &#125; &#125; &#125;).start();&#125;); 再次运行程序： 成功解决~。 7、球与球之间的碰撞为完成小球之间的碰撞问题，我们需要了解小球碰撞后各自的运动轨迹和速度，这涉及到中学的物理知识，为进一步方便让我们便于理解，我们将模型化至最简，即不考虑摩擦力、小球本身的旋转方向、小球的质量（在本模型中所有的小球质量都相等）、能量无损失等因素。 我们设小球1碰撞前的速度为$v_1$，小球2碰撞前的速度为$v_2$，根据动量守恒和动能守恒，可得方程组： \begin{cases} v_1 + v_2 = v_1' + v_2'\\ v_1^2 + v_1^2 = v_1'^2 + v_2'^2 \end{cases}解得： \begin{cases} v_1' = v_2\\ v_2' = v_1 \end{cases}将两个小球碰撞后的速度 $v_1’$ 和 $v_2’$ 分解到小球对应速度的$x$和$y$方向上： \begin{cases} v_{1x}' = v_{2x}\\ v_{2x}' = v_{1x}\\ v_{1y}' = v_{2y}\\ v_{2y}' = v_{1y} \end{cases}对此，我们也就可以写出相应的代码了： 123456789101112131415161718192021public class Circle &#123; // ... // 球与球之间的碰撞 private void checkCircleCollision(Circle another) &#123; // 先把两个小球碰撞前的速度保存起来 int vx_temp = vx; int vy_temp = vy; int vx_another_temp = another.vx; int vy_another_temp = another.vy; // 两小球球心的距离 int d = (int) Math.sqrt((x - another.x) * (x - another.x) + (y - another.y) * (y - another.y)); if (d &lt;= 2 * r) &#123; vx = vx_another_temp; another.vx = vx_temp; vy = vy_another_temp; another.vy = vy_temp; &#125; &#125;&#125; 把这段代码放到move方法中进行调用： 123456789// 多传进来一个Circle数组，对每一个Circle进行小球之间的碰撞检测public void move(int minX, int minY, int maxX, int maxY, Circle[] circles) &#123; x += vx; y += vy; checkWallCollision(minX, minY, maxX, maxY); for (Circle circle : circles) &#123; checkCircleCollision(circle); &#125;&#125; 与此同时我们也得修改main方法中调用的move方法： 123456// ...保持不变// 更新数据for (Circle circle : circles) &#123; circle.move(0, 0, sceneWidth, sceneHeight, circles); // 将初始化的Circle[]传进去&#125;// ...保持不变 运行代码： 成功~~ 8、解决小球初始生成位置的一点小BUG在我们的程序中，我们的小球在初始生成的时候，会出现一点小BUG，看起来挺尴尬的： 解决方案： 我们先来看我们生成小球初始位置的算法： 12int x = (int) ((Math.random() * (sceneWidth - 2 * R)) + R);int y = (int) ((Math.random() * (sceneHeight - 2 * R)) + R); 这样子可能会导致两次生成的x，y靠的比较近，也就是会产生小球相交的情况。 为避免这个现象，我们现在将整个画布分成 棋盘格 的形式 为每一个格子做一个标记，有小球置为true，没有则置为false。 1boolean[][] isCircle = new boolean[sceneWidth/(2*R)][sceneHeight/(2*R)]; // 初始都默认为false 现在在画布随机生成一个坐标(m,n)，用这个坐标除以单元格的长度，可以得到这个坐标位于第几个格子里，也就小球生成的格子所在。 12int m = (int) (Math.random() * sceneWidth) / (2 * R);int n = (int) (Math.random() * sceneHeight) / (2 * R); 对(m,n)这个格子进行判断，如果有则重新生成新的随机坐标，没有则把小球放在这个格子，isCircle[m][n]置为true，并计算小球的圆心坐标也就是格子正中心的位置。 123x = m * (R + R) + R;y = n * (R + R) + R;isCircle[m][n] = true; 整体代码： 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; // ... boolean[][] isCircle = new boolean[sceneWidth/(2*R)][sceneHeight/(2*R)]; for (int i = 0; i &lt; N; i++) &#123; int x = -1, y = -1; int m = (int) (Math.random() * sceneWidth) / (2 * R); int n = (int) (Math.random() * sceneHeight) / (2 * R); while (true) &#123; if (isCircle[m][n]) &#123; // 如果当前格子已经有小球了，继续循环，重新随机生成一个位置 m = (int) (Math.random() * sceneWidth) / (2 * R); n = (int) (Math.random() * sceneHeight) / (2 * R); &#125; else &#123; // 如果当前格子里什么都没有，在此处生成一个小球并跳出循环 x = m * (R + R) + R; y = n * (R + R) + R; isCircle[m][n] = true; break; &#125; &#125; int vx = (int) (Math.random() * 11) - 5; int vy = (int) (Math.random() * 11) - 5; circles[i] = new Circle(x, y, R, vx, vy); &#125; // ... &#125;&#125; 这样，两个小球在最开始生成的时候就不会出现重叠的情况了。 9、MVC结构设计在上面的例子中，我们的main方法要处理的逻辑实在有点多，看起来很乱，层次结构不是很清晰。因此我们把main方法中的逻辑都抽取出来，放进一个单独的类里面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CircleVisualizer &#123; private CircleFrame frame; // 设置数据 private Circle[] circles; public CircleVisualizer(int sceneWidth, int sceneHeight, int N) &#123; // 初始化数据 circles = new Circle[N]; int R = 50; boolean[][] isCircle = new boolean[sceneWidth/(2*R)][sceneHeight/(2*R)]; for (int i = 0; i &lt; N; i++) &#123; int x = -1, y = -1; int m = (int) (Math.random() * sceneWidth) / (2 * R); int n = (int) (Math.random() * sceneHeight) / (2 * R); while (true) &#123; if (isCircle[m][n]) &#123; // 如果当前格子已经有小球了，继续循环，重新随机生成一个位置 m = (int) (Math.random() * sceneWidth) / (2 * R); n = (int) (Math.random() * sceneHeight) / (2 * R); &#125; else &#123; // 如果当前格子里什么都没有，在此处生成一个小球并跳出循环 x = m * (R + R) + R; y = n * (R + R) + R; isCircle[m][n] = true; break; &#125; &#125; int vx = (int) (Math.random() * 11) - 5; int vy = (int) (Math.random() * 11) - 5; circles[i] = new Circle(x, y, R, vx, vy); &#125; // 初始化视图 EventQueue.invokeLater(() -&gt; &#123; frame = new CircleFrame("碰撞的小球", sceneWidth, sceneHeight); new Thread(() -&gt; &#123; run(); &#125;).start(); &#125;); &#125; private void run() &#123; while (true) &#123; // 绘制数据 frame.render(circles); CircleHelper.pause(20); // 更新数据 for (Circle circle : circles) &#123; circle.move(0, 0, frame.getCanvasWidth(), frame.getCanvasHeight(), circles); &#125; &#125; &#125;&#125; 这样我们在main方法中只要声明宽高，小球数量，在实例化CircleVisualizer类就可以了。 1234567891011public class Main &#123; public static void main(String[] args) &#123; int sceneWidth = 800; int sceneHeight = 800; int N = 10; new CircleVisualizer(sceneWidth, sceneHeight, N); &#125;&#125; 在本案例中： CircleVisualizer类负责处理数据的变化，充当了MVC中的Controller层 CircleFrame类负责绘制图像，将图像呈现给用户，充当了MVC中的View层 Circle类（实际上应该是Circle[]）就是MVC中的Model层 将程序分为以上三层，不仅让代码结构变得清晰，而且可以让我们后续的算法可视化程序中套用该模板。 10、添加交互事件在本案例中我们还是采用内部私有类的方式来实现键盘和鼠标的交互事件。 添加键盘事件添加键盘事件的方式有两种： 一是实现KeyListener接口 1234567891011121314public class CircleVisualizer &#123; // ... private class CircleKeyListener implements KeyListener &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;&#125; 二是继承KeyAdapter类 12345678public class CircleVisualizer &#123; // ... private class CircleKeyListener extends KeyAdapter &#123; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;&#125; 实现接口就必须要重写该接口定义的所有方法，而我们只需要重写keyReleased这个方法，因此选择继承KeyAdapter类来实现键盘交互事件。 在本案例中，我们按下键盘的空格键让所有运动的小球都变得停止，再次按下让小球继续运动。代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class CircleVisualizer &#123; // ... public CircleVisualizer(int sceneWidth, int sceneHeight, int N) &#123; // 初始化数据 // ... // 初始化视图 EventQueue.invokeLater(() -&gt; &#123; frame = new CircleFrame("碰撞的小球", sceneWidth, sceneHeight); // 小球在窗体中的运动/静止状态都是frame进行绘制的，因此键盘事件要添加给frame frame.addKeyListener(new CircleKeyListener()); // 将键盘事件添加给frame new Thread(() -&gt; &#123; run(); &#125;).start(); &#125;); &#125; private void run() &#123; while (true) &#123; // 绘制数据 // ... // 更新数据 if (isAnimated) &#123; // 根据小球运动状态来绘制 for (Circle circle : circles) &#123; circle.move(0, 0, frame.getCanvasWidth(), frame.getCanvasHeight(), circles); &#125; &#125; &#125; &#125; private boolean isAnimated = true; // 小球是否在运动，默认是在运动 private class CircleKeyListener extends KeyAdapter &#123; @Override public void keyReleased(KeyEvent e) &#123; if (e.getKeyChar() == ' ') &#123; // 如果按的是空格键 isAnimated = !isAnimated; // 改变小球的运动状态 &#125; &#125; &#125;&#125; 添加鼠标事件添加鼠标事件和键盘事件一样，我们选择内部私有类继承MouseAdapter类。 在窗体中，我们点击一个小球改变其颜色，再次点击还原其颜色1、 获取鼠标点击的位置System.out.println(e.getPoint()); // 获得鼠标点击位置 由于窗体标题栏和边框的干扰，我们用e.getPoint()获取到的坐标往往不是我们想要的坐标，因此要进行微调，用e.translatePoint(int x,int y)方法进行调整，具体调整的数值要根据自己的情况来调整。 12345678private class CircleMouseListener extends MouseAdapter &#123; @Override public void mousePressed(MouseEvent e) &#123; e.translatePoint(-3, -(frame.getBounds().height-frame.getCanvasHeight())+13);// System.out.println(e.getPoint()); // 获得鼠标点击位置 &#125;&#125; 2、判断鼠标点击的位置是否在一个小球内12345678public class Circle &#123; // ... public boolean isFilled = false; // 初始为空心圆 // y用两点间的距离公式进行判断 public boolean contain(Point p) &#123; return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y) &lt;= r * r; &#125;&#125; 12345678910@Overridepublic void mousePressed(MouseEvent e) &#123; e.translatePoint(-3, -(frame.getBounds().height-frame.getCanvasHeight())+13);// System.out.println(e.getPoint()); // 获得鼠标点击位置 for (Circle circle : circles) &#123; // 对每一个小球进行判断 if (circle.contain(e.getPoint())) &#123; // 如果有小球包含该点 circle.isFilled = !circle.isFilled; // 改变小球的颜色状态 &#125; &#125;&#125; 3、修改CircleFrame里面的绘制小球代码部分根据小球的isFilled属性进行绘制 12345678910111213141516171819public class CircleFrame extends JFrame &#123; // ... private class CircleCanvas extends JPanel &#123; // ... @Override protected void paintComponent(Graphics g) &#123; // ... // 具体绘制 CircleHelper.setStrokeWidth(g2d, 1); CircleHelper.setColor(g2d, Color.RED); for (Circle circle : circles) &#123; if (!circle.isFilled) CircleHelper.drawCircle(g2d, circle.x, circle.y, circle.getR()); // 绘制空心圆 else CircleHelper.fillCircle(g2d, circle.x, circle.y, circle.getR()); // 绘制实心圆 &#125; &#125; &#125;&#125; 4、运行结果 11、抽取MVC模板View层：ObjectFrame.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ObjectFrame extends JFrame &#123; private int canvasWidth; private int canvasHeight; public ObjectFrame(String title, int canvasWidth, int canvasHeight) &#123; super(title); this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight; ObjectCanvas canvas = new ObjectCanvas(); this.setContentPane(canvas); this.pack(); this.setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setVisible(true); &#125; public ObjectFrame(String title) &#123; this(title, 1024, 768); &#125; public int getCanvasWidth() &#123; return canvasWidth; &#125; public int getCanvasHeight() &#123; return canvasHeight; &#125; // 对传递进来的数据进行渲染 private Object object; public void render(Object object) &#123; this.object = object; this.repaint(); &#125; private class ObjectCanvas extends JPanel &#123; public ObjectCanvas() &#123; super(true); &#125; @Override protected void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; // 抗锯齿 RenderingHints hints = new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2d.addRenderingHints(hints); // 具体绘制 // TODO &#125; @Override public Dimension getPreferredSize() &#123; return new Dimension(canvasWidth, canvasHeight); &#125; &#125;&#125; Controller层：ObjectVisualizer.java1234567891011121314151617181920212223242526272829303132333435363738394041public class ObjectVisualizer &#123; // 设置数据 private Object object; private ObjectFrame frame; public ObjectVisualizer(int sceneWidth, int sceneHeight, int N) &#123; // 初始化数据 // 对object进行初始化 // 初始化视图 EventQueue.invokeLater(() -&gt; &#123; frame = new ObjectFrame("title", sceneWidth, sceneHeight); // 根据具体情况添加键盘鼠标事件 // frame.addKeyListener(new ObjectKeyListener()); // 添加键盘事件 // frame.addMouseListener(new ObjectMouseListener()); // 添加鼠标事件 new Thread(() -&gt; &#123; run(); &#125;).start(); &#125;); &#125; private void run() &#123; while (true) &#123; // 绘制数据 frame.render(object); CircleHelper.pause(20); // 更新数据 // ... &#125; &#125; private class ObjectKeyListener extends KeyAdapter &#123; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125; private class ObjectMouseListener extends MouseAdapter &#123; @Override public void mousePressed(MouseEvent e) &#123; &#125; &#125;&#125; Model层：Object.java123public class Object &#123; // 设置object的属性等...&#125; 辅助工具类：ObjectHelper.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class ObjectHelper &#123; private ObjectHelper() &#123;&#125; public static final Color Red = new Color(0xF44336); public static final Color Pink = new Color(0xE91E63); public static final Color Purple = new Color(0x9C27B0); public static final Color DeepPurple = new Color(0x673AB7); public static final Color Indigo = new Color(0x3F51B5); public static final Color Blue = new Color(0x2196F3); public static final Color LightBlue = new Color(0x03A9F4); public static final Color Cyan = new Color(0x00BCD4); public static final Color Teal = new Color(0x009688); public static final Color Green = new Color(0x4CAF50); public static final Color LightGreen = new Color(0x8BC34A); public static final Color Lime = new Color(0xCDDC39); public static final Color Yellow = new Color(0xFFEB3B); public static final Color Amber = new Color(0xFFC107); public static final Color Orange = new Color(0xFF9800); public static final Color DeepOrange = new Color(0xFF5722); public static final Color Brown = new Color(0x795548); public static final Color Grey = new Color(0x9E9E9E); public static final Color BlueGrey = new Color(0x607D8B); public static final Color Black = new Color(0x000000); public static final Color White = new Color(0xFFFFFF); public static void setStrokeWidth(Graphics2D g2d, int width) &#123; g2d.setStroke(new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND)); &#125; public static void setColor(Graphics2D g2d, Color color) &#123; g2d.setColor(color); &#125; public static void drawCircle(Graphics2D g2d, int x, int y, int r) &#123; Ellipse2D circle = new Ellipse2D.Double(x-r, y-r, 2*r, 2*r); g2d.draw(circle); &#125; public static void fillCircle(Graphics2D g2d, int x, int y, int r) &#123; Ellipse2D circle = new Ellipse2D.Double(x-r, y-r, 2*r, 2*r); g2d.fill(circle); &#125; public static void drawRectangle(Graphics2D g2d, int x, int y, int w, int h) &#123; Rectangle2D rectangle = new Rectangle2D.Double(x, y, w, h); g2d.draw(rectangle); &#125; public static void fillRectangle(Graphics2D g2d, int x, int y, int w, int h) &#123; Rectangle2D rectangle = new Rectangle2D.Double(x, y, w, h); g2d.fill(rectangle); &#125; public static void drawText(Graphics2D g, String text, int centerX, int centerY)&#123; if(text == null) throw new IllegalArgumentException("Text is null in drawText function!"); FontMetrics metrics = g.getFontMetrics(); int w = metrics.stringWidth(text); int h = metrics.getDescent(); g.drawString(text, centerX - w/2, centerY + h); &#125; public static void pause(int t) &#123; try &#123; Thread.sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 模板记得单独保存一下，后面的程序都会套用该模板。 12、第一章结束，下一章再见：）至此，我们用Java Swing模拟一个小球碰撞的场景就算完成了。 不过我们的程序依旧存在着bug，比如，让程序运行一会，还是有可能会在小球碰撞过程中出现相交的情况。 一是由于采用int型来获取两小球之间的距离，产生了精度丢失 int d = (int) Math.sqrt((x - another.x) * (x - another.x) + (y - another.y) * (y - another.y)); 二是由于计算机绘制的速度过快，导致小球在还未进行碰撞检测前就已经交织在一起了。 有兴趣的同学不妨自己去思考怎么解决这个问题，希望大家多多加油！！]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>java swing</tag>
        <tag>可视化</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
</search>
